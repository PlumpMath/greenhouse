
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>greenhouse.utils – Greenlet-Aware Concurrency Primitives &mdash; greenhouse v0.6.0 documentation</title>
    <link rel="stylesheet" href="../static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="greenhouse v0.6.0 documentation" href="../index.html" />
    <link rel="next" title="greenhouse.pool – Managed Greenlet Pools" href="pool.html" />
    <link rel="prev" title="greenhouse.io – Cooperative I/O Drop-Ins" href="io.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pool.html" title="greenhouse.pool – Managed Greenlet Pools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="io.html" title="greenhouse.io – Cooperative I/O Drop-Ins"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">greenhouse v0.6.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-greenhouse.utils">
<span id="greenhouse-utils-greenlet-aware-concurrency-primitives"></span><h1><a class="reference internal" href="#module-greenhouse.utils" title="greenhouse.utils"><tt class="xref py py-mod docutils literal"><span class="pre">greenhouse.utils</span></tt></a> &#8211; Greenlet-Aware Concurrency Primitives<a class="headerlink" href="#module-greenhouse.utils" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="greenhouse.utils.Event">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Event</tt><a class="headerlink" href="#greenhouse.utils.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>an event for which greenlets can wait</p>
<p>mirrors the standard library <cite>threading.Event</cite> API</p>
<dl class="method">
<dt id="greenhouse.utils.Event.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Event.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear the event from being triggered</p>
<p>after calling this method, waiting on this event will block until the
<a class="reference internal" href="#greenhouse.utils.Event.set" title="greenhouse.utils.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> method has been called</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Event.isSet">
<tt class="descname">isSet</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Event.isSet" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates whether waiting on the event will block right now</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if the event has been <a class="reference internal" href="#greenhouse.utils.Event.set" title="greenhouse.utils.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> and waiting will not
block, <tt class="xref docutils literal"><span class="pre">False</span></tt> if the event is <a class="reference internal" href="#greenhouse.utils.Event.clear" title="greenhouse.utils.Event.clear"><tt class="xref py py-meth docutils literal"><span class="pre">cleared</span></tt></a> and
<a class="reference internal" href="#greenhouse.utils.Event.wait" title="greenhouse.utils.Event.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> will block</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Event.is_set">
<tt class="descname">is_set</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Event.is_set" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates whether waiting on the event will block right now</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if the event has been <a class="reference internal" href="#greenhouse.utils.Event.set" title="greenhouse.utils.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> and waiting will not
block, <tt class="xref docutils literal"><span class="pre">False</span></tt> if the event is <a class="reference internal" href="#greenhouse.utils.Event.clear" title="greenhouse.utils.Event.clear"><tt class="xref py py-meth docutils literal"><span class="pre">cleared</span></tt></a> and
<a class="reference internal" href="#greenhouse.utils.Event.wait" title="greenhouse.utils.Event.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> will block</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Event.set">
<tt class="descname">set</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Event.set" title="Permalink to this definition">¶</a></dt>
<dd><p>set the event to triggered</p>
<p>after calling this method, all greenlets waiting on the event will be
rescheduled, and calling <a class="reference internal" href="#greenhouse.utils.Event.wait" title="greenhouse.utils.Event.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> will not block until
<a class="reference internal" href="#greenhouse.utils.Event.clear" title="greenhouse.utils.Event.clear"><tt class="xref py py-meth docutils literal"><span class="pre">clear()</span></tt></a> has been called</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Event.wait">
<tt class="descname">wait</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Event.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>pause the current coroutine until this event is set</p>
<p>if <a class="reference internal" href="#greenhouse.utils.Event.set" title="greenhouse.utils.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> method has been called, this method will not block at
all. otherwise it will block until <a class="reference internal" href="#greenhouse.utils.Event.set" title="greenhouse.utils.Event.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> method is called</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timeout</strong> (<em>number or None</em>) &#8211; the maximum amount of time to block in seconds. the default of
<tt class="xref docutils literal"><span class="pre">None</span></tt> allows indefinite blocking.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><tt class="xref docutils literal"><span class="pre">True</span></tt> if a timeout was provided and was hit, otherwise <tt class="xref docutils literal"><span class="pre">False</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Lock">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Lock</tt><a class="headerlink" href="#greenhouse.utils.Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>an object that can only be &#8216;owned&#8217; by one greenlet at a time</p>
<p>mirrors the standard library <cite>threading.Lock</cite> API</p>
<dl class="method">
<dt id="greenhouse.utils.Lock.acquire">
<tt class="descname">acquire</tt><big>(</big><em>blocking=True</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Lock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>lock the lock, blocking until it becomes available</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether to block if the lock is already owned (default <tt class="xref docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a <cite>bool</cite> indicating whether the lock was acquired. In the default
case of <tt class="docutils literal"><span class="pre">blocking</span> <span class="pre">=</span> <span class="pre">True</span></tt> this will always be the case, but may
not be otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Lock.locked">
<tt class="descname">locked</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Lock.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates whether the lock is currently locked</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if the lock is locked (and therefore calling
<a class="reference internal" href="#greenhouse.utils.Lock.acquire" title="greenhouse.utils.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt></a> would block), otherwise <tt class="xref docutils literal"><span class="pre">False</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Lock.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Lock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>open the lock back up to wake up a waiting greenlet</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><cite>RuntimeError</cite> if the calling greenlet is not the one that had
<a class="reference internal" href="#greenhouse.utils.Lock.acquire" title="greenhouse.utils.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquired</span></tt></a> the lock</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.RLock">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">RLock</tt><a class="headerlink" href="#greenhouse.utils.RLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#greenhouse.utils.Lock" title="greenhouse.utils.Lock"><tt class="xref py py-class docutils literal"><span class="pre">greenhouse.utils.Lock</span></tt></a></p>
<p>a lock which may be acquired more than once by the same greenlet</p>
<p>mirrors the standard library <cite>threading.RLock</cite> API</p>
<dl class="method">
<dt id="greenhouse.utils.RLock.acquire">
<tt class="descname">acquire</tt><big>(</big><em>blocking=True</em><big>)</big><a class="headerlink" href="#greenhouse.utils.RLock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire ownership of the lock</p>
<p>if the lock is already owned by the calling greenlet, a counter simply
gets incremented. if it is owned by a different greenlet then it will
block until the lock becomes available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether to block if the lock is owned by a different greenlet
(default <tt class="xref docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a <cite>bool</cite> indicating whether the lock was acquired. In the default
case of <tt class="docutils literal"><span class="pre">blocking</span> <span class="pre">=</span> <span class="pre">True</span></tt> this will always be the case, but may
not be otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.RLock.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.RLock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>release one ownership of the lock</p>
<p>if the calling greenlet has <a class="reference internal" href="#greenhouse.utils.RLock.acquire" title="greenhouse.utils.RLock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquired</span></tt></a> the lock more
than once this will simply decrement the counter. if this is a final
release then a waiting greenlet is awoken</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><cite>RuntimeError</cite> if the calling greenlet is not the lock&#8217;s owner</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Condition">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Condition</tt><big>(</big><em>lock=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>a synchronization object capable of waking all or one of its waiters</p>
<p>mirrors the standard library <cite>threading.Condition</cite> API</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lock</strong> (<a class="reference internal" href="#greenhouse.utils.Lock" title="greenhouse.utils.Lock"><tt class="xref py py-class docutils literal"><span class="pre">Lock</span></tt></a> or <a class="reference internal" href="#greenhouse.utils.RLock" title="greenhouse.utils.RLock"><tt class="xref py py-class docutils literal"><span class="pre">RLock</span></tt></a>) &#8211; the lock object wrapped by the condition</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="greenhouse.utils.Condition.notify">
<tt class="descname">notify</tt><big>(</big><em>num=1</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Condition.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>wake one or more waiting greenlets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num</strong> (<em>int</em>) &#8211; the number of waiters to wake (default 1)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last"><cite>RuntimeError</cite> if the underlying lock hasn&#8217;t been
<a class="reference internal" href="#greenhouse.utils.Lock.acquire" title="greenhouse.utils.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquired</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Condition.notifyAll">
<tt class="descname">notifyAll</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Condition.notifyAll" title="Permalink to this definition">¶</a></dt>
<dd><p>wake all waiting greenlets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><cite>RuntimeError</cite> if the underlying lock hasn&#8217;t been
<a class="reference internal" href="#greenhouse.utils.Lock.acquire" title="greenhouse.utils.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquired</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Condition.notify_all">
<tt class="descname">notify_all</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Condition.notify_all" title="Permalink to this definition">¶</a></dt>
<dd><p>wake all waiting greenlets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><cite>RuntimeError</cite> if the underlying lock hasn&#8217;t been
<a class="reference internal" href="#greenhouse.utils.Lock.acquire" title="greenhouse.utils.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquired</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Condition.wait">
<tt class="descname">wait</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Condition.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait to be woken up by the condition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><cite>RuntimeError</cite> if the underlying lock hasn&#8217;t been
<a class="reference internal" href="#greenhouse.utils.Lock.acquire" title="greenhouse.utils.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquired</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Semaphore">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Semaphore</tt><big>(</big><em>value=1</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Semaphore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>a synchronization object with a counter that blocks when it reaches 0</p>
<p>mirrors the api of <cite>threading.Semaphore</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> (<em>int</em>) &#8211; the starting value of the counter</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="greenhouse.utils.Semaphore.acquire">
<tt class="descname">acquire</tt><big>(</big><em>blocking=True</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Semaphore.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement the counter, blocking if it is already at 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether or not to block if the counter is already at 0 (default
<tt class="xref docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a bool, indicating whether the count was decremented (this can only
be <tt class="xref docutils literal"><span class="pre">False</span></tt> if <tt class="docutils literal"><span class="pre">blocking</span></tt> was <tt class="xref docutils literal"><span class="pre">False</span></tt> &#8211; otherwise it would
have blocked until it could decrement the counter)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Semaphore.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Semaphore.release" title="Permalink to this definition">¶</a></dt>
<dd><p>increment the counter, waking up a waiter if there was any</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.BoundedSemaphore">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">BoundedSemaphore</tt><big>(</big><em>value=1</em><big>)</big><a class="headerlink" href="#greenhouse.utils.BoundedSemaphore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#greenhouse.utils.Semaphore" title="greenhouse.utils.Semaphore"><tt class="xref py py-class docutils literal"><span class="pre">greenhouse.utils.Semaphore</span></tt></a></p>
<p>a semaphore with an upper limit to the counter</p>
<p>mirrors the api of <cite>threading.BoundedSemaphore</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> (<em>int</em>) &#8211; the starting and maximum value of the counter</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="greenhouse.utils.BoundedSemaphore.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.BoundedSemaphore.release" title="Permalink to this definition">¶</a></dt>
<dd><p>increment the counter, waking up a waiter if there was any</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Timer">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Timer</tt><big>(</big><em>secs</em>, <em>func</em>, <em>args=()</em>, <em>kwargs=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>creates a greenlet from a function and schedules it to run later</p>
<p>mirrors the standard library <cite>threading.Timer</cite> API</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>secs</strong> (<em>int or float</em>) &#8211; how far in the future to defer running the function in seconds</li>
<li><strong>func</strong> (<em>function</em>) &#8211; the function to run later</li>
<li><strong>args</strong> (<em>tuple</em>) &#8211; positional arguments to pass to the function</li>
<li><strong>kwargs</strong> (<em>dict</em>) &#8211; keyword arguments to pass to the function</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="greenhouse.utils.Timer.cancel">
<tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Timer.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to prevent the timer from ever running its function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if it was successful, <tt class="xref docutils literal"><span class="pre">False</span></tt> if the timer had already
run or been cancelled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="greenhouse.utils.Timer.wrap">
<em class="property">classmethod </em><tt class="descname">wrap</tt><big>(</big><em>secs</em>, <em>args=()</em>, <em>kwargs=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Timer.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>a classmethod decorator to immediately turn a function into a timer</p>
<p>you won&#8217;t find this on <cite>threading.Timer</cite>, it is an extension to that API</p>
<p>this is a function <em>returning a decorator</em>, so it is used like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@Timer.wrap</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">say_hi_timer</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;hello, </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">name</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>secs</strong> (<em>int or float</em>) &#8211; how far in the future to defer running the function in seconds</li>
<li><strong>args</strong> (<em>tuple</em>) &#8211; positional arguments to pass to the function</li>
<li><strong>kwargs</strong> (<em>dict</em>) &#8211; keyword arguments to pass to the function</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a decorator function</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Local">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Local</tt><a class="headerlink" href="#greenhouse.utils.Local" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>an object that holds greenlet-local data</p>
<p>mirrors the standard library <cite>threading.local</cite> API</p>
<p>to use, simply create an instance with no arguments, and any attribute gets
and sets will be specific to that greenlet</p>
</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Thread">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Thread</tt><big>(</big><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>a standin class for threads, but powered by greenlets</p>
<p>this class is useful for <a class="reference internal" href="emulation.html#module-greenhouse.emulation" title="greenhouse.emulation"><tt class="xref py py-mod docutils literal"><span class="pre">monkey-patching</span></tt></a>
the standard library, but for code written explicitly for greenhouse, the
functions in <a class="reference internal" href="scheduler.html#module-greenhouse.scheduler" title="greenhouse.scheduler"><tt class="xref py py-mod docutils literal"><span class="pre">greenhouse.scheduler</span></tt></a> are a better way to go</p>
<p>mirrors the standard library <cite>threading.Thread</cite> API</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>group</strong> (<em>None</em>) &#8211; this argument does nothing and must be <tt class="xref docutils literal"><span class="pre">None</span></tt> (for compatibility with
the standard library <cite>threading.Thread</cite>)</li>
<li><strong>target</strong> (<em>function</em>) &#8211; the function to run in the greenlet</li>
<li><strong>name</strong> (<em>str</em>) &#8211; the thread name (defaults to a generated name)</li>
<li><strong>args</strong> (<em>tuple</em>) &#8211; positional arguments to pass in to the <cite>target</cite> function</li>
<li><strong>kwargs</strong> (<em>dict</em>) &#8211; keyword arguments to pass to the <cite>target</cite> function</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; here for compatibility, it is actually ignored</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="greenhouse.utils.Thread.daemon">
<tt class="descname">daemon</tt><a class="headerlink" href="#greenhouse.utils.Thread.daemon" title="Permalink to this definition">¶</a></dt>
<dd><p>whether the thread is set as a daemon thread (unsupported)</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.getName">
<tt class="descname">getName</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>the thread&#8217;s name as passed in the constructor or <a class="reference internal" href="#greenhouse.utils.Thread.set_name" title="greenhouse.utils.Thread.set_name"><tt class="xref py py-meth docutils literal"><span class="pre">set_name()</span></tt></a>,
or failing those the automatically generated name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the thread&#8217;s <cite>str</cite> name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.get_name">
<tt class="descname">get_name</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.get_name" title="Permalink to this definition">¶</a></dt>
<dd><p>the thread&#8217;s name as passed in the constructor or <a class="reference internal" href="#greenhouse.utils.Thread.set_name" title="greenhouse.utils.Thread.set_name"><tt class="xref py py-meth docutils literal"><span class="pre">set_name()</span></tt></a>,
or failing those the automatically generated name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the thread&#8217;s <cite>str</cite> name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="greenhouse.utils.Thread.ident">
<tt class="descname">ident</tt><a class="headerlink" href="#greenhouse.utils.Thread.ident" title="Permalink to this definition">¶</a></dt>
<dd><p>unique identifier for this thread</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates whether the thread is currently running</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if <a class="reference internal" href="#greenhouse.utils.Thread.start" title="greenhouse.utils.Thread.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a> has already been called but the function
hasn&#8217;t yet finished or been killed, <tt class="xref docutils literal"><span class="pre">False</span></tt> if it isn&#8217;t currently
running for any reason.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.isDaemon">
<tt class="descname">isDaemon</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.isDaemon" title="Permalink to this definition">¶</a></dt>
<dd><p>whether the thread is in daemonized mode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">False</span></tt>. this is here for compatibility with <cite>threading.Thread</cite>,
but daemonized mode is not supported.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.is_alive">
<tt class="descname">is_alive</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.is_alive" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates whether the thread is currently running</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if <a class="reference internal" href="#greenhouse.utils.Thread.start" title="greenhouse.utils.Thread.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a> has already been called but the function
hasn&#8217;t yet finished or been killed, <tt class="xref docutils literal"><span class="pre">False</span></tt> if it isn&#8217;t currently
running for any reason.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.is_daemon">
<tt class="descname">is_daemon</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.is_daemon" title="Permalink to this definition">¶</a></dt>
<dd><p>whether the thread is in daemonized mode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">False</span></tt>. this is here for compatibility with <cite>threading.Thread</cite>,
but daemonized mode is not supported.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.join">
<tt class="descname">join</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.join" title="Permalink to this definition">¶</a></dt>
<dd><p>block until this thread terminates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timeout</strong> (<em>int, float or None</em>) &#8211; the maximum time to wait. with the default of <tt class="xref docutils literal"><span class="pre">None</span></tt>, waits
indefinitely</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last"><cite>RuntimeError</cite> if called inside the thread, or it has not yet been
started</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.run">
<tt class="descname">run</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.run" title="Permalink to this definition">¶</a></dt>
<dd><p>override this method to define the thread&#8217;s behavior</p>
<p>this is an alternative way to define the thread&#8217;s function than passing
<cite>target</cite> to the constructor</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.setDaemon">
<tt class="descname">setDaemon</tt><big>(</big><em>daemonic</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.setDaemon" title="Permalink to this definition">¶</a></dt>
<dd><p>here for compatibility with <cite>threading.Thread</cite>, this doesn&#8217;t work</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>daemonic</strong> (<em>bool</em>) &#8211; whether attempting to turn daemon mode on or off</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last"><cite>RuntimeError</cite> when attempting to turn on daemonic mode</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.setName">
<tt class="descname">setName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.setName" title="Permalink to this definition">¶</a></dt>
<dd><p>overwrite the thread&#8217;s name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; the name to set</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.set_daemon">
<tt class="descname">set_daemon</tt><big>(</big><em>daemonic</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.set_daemon" title="Permalink to this definition">¶</a></dt>
<dd><p>here for compatibility with <cite>threading.Thread</cite>, this doesn&#8217;t work</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>daemonic</strong> (<em>bool</em>) &#8211; whether attempting to turn daemon mode on or off</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last"><cite>RuntimeError</cite> when attempting to turn on daemonic mode</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.set_name">
<tt class="descname">set_name</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>overwrite the thread&#8217;s name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; the name to set</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Thread.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Thread.start" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule to start the greenlet that runs this thread&#8217;s function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><cite>RuntimeError</cite> if the thread has already been started</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Queue">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Queue</tt><big>(</big><em>maxsize=0</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>a producer-consumer queue</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>maxsize</strong> (<em>int</em>) &#8211; optional limit to the amount of queued data, after which <a class="reference internal" href="#greenhouse.utils.Queue.put" title="greenhouse.utils.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a>
can block. the default of 0 turns off the limit, so <a class="reference internal" href="#greenhouse.utils.Queue.put" title="greenhouse.utils.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> will
never block</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>mirrors the standard library <cite>Queue.Queue</cite> API</p>
<dl class="method">
<dt id="greenhouse.utils.Queue.empty">
<tt class="descname">empty</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>indicate whether there is any queued data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if there is data in the queue, otherwise <tt class="xref docutils literal"><span class="pre">False</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.full">
<tt class="descname">full</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.full" title="Permalink to this definition">¶</a></dt>
<dd><p>indicate whether the queue has <cite>maxsize</cite> data queued</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="xref docutils literal"><span class="pre">True</span></tt> if the queue&#8217;s data has reached <cite>maxsize</cite>, otherwise
<tt class="xref docutils literal"><span class="pre">False</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.get">
<tt class="descname">get</tt><big>(</big><em>blocking=True</em>, <em>timeout=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.get" title="Permalink to this definition">¶</a></dt>
<dd><p>get an item out of the queue</p>
<p>this method will block if <cite>blocking</cite> is <tt class="xref docutils literal"><span class="pre">True</span></tt> (default) and the
queue is <a class="reference internal" href="#greenhouse.utils.Queue.empty" title="greenhouse.utils.Queue.empty"><tt class="xref py py-meth docutils literal"><span class="pre">empty()</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether to block if there is no data yet available (default
<tt class="xref docutils literal"><span class="pre">True</span></tt>)</li>
<li><strong>timeout</strong> (<em>int, float or None</em>) &#8211; the maximum time in seconds to block waiting for data. with the
default of <tt class="xref docutils literal"><span class="pre">None</span></tt>, can wait indefinitely. this is unused if
<cite>blocking</cite> is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><tt class="xref py py-class docutils literal"><span class="pre">Empty</span></tt> if there is no data in the queue and blocking is
<tt class="xref docutils literal"><span class="pre">False</span></tt>, or <cite>timeout</cite> expires</p>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">something that was previously <a class="reference internal" href="#greenhouse.utils.Queue.put" title="greenhouse.utils.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> in the queue</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.get_nowait">
<tt class="descname">get_nowait</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.get_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>get an item out of the queue without ever blocking</p>
<p>this call is equivalent to <tt class="docutils literal"><span class="pre">get(blocking=False)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">something that was previously <a class="reference internal" href="#greenhouse.utils.Queue.put" title="greenhouse.utils.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> in the queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.join">
<tt class="descname">join</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.join" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for task completions</p>
<p>blocks until either <a class="reference internal" href="#greenhouse.utils.Queue.task_done" title="greenhouse.utils.Queue.task_done"><tt class="xref py py-meth docutils literal"><span class="pre">task_done()</span></tt></a> has been called for every
<a class="reference internal" href="#greenhouse.utils.Queue.put" title="greenhouse.utils.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> call</p>
<p>the queue is still usable after a <a class="reference internal" href="#greenhouse.utils.Queue.join" title="greenhouse.utils.Queue.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> call. a return from
<a class="reference internal" href="#greenhouse.utils.Queue.join" title="greenhouse.utils.Queue.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> simply indicates that the queue has no jobs <cite>currently</cite>
pending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timeout</strong> (<em>int, float or None</em>) &#8211; the maximum amount of time to wait in seconds. the default of
<tt class="xref docutils literal"><span class="pre">None</span></tt> allows indefinite waiting.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><tt class="xref docutils literal"><span class="pre">True</span></tt> if <cite>timeout</cite> was provided and expired, otherwise <tt class="xref docutils literal"><span class="pre">False</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.put">
<tt class="descname">put</tt><big>(</big><em>item</em>, <em>blocking=True</em>, <em>timeout=None</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.put" title="Permalink to this definition">¶</a></dt>
<dd><p>put an item into the queue</p>
<p>if the queue was instantiated with a nonzero <cite>maxsize</cite> and that size
has already been reached, this method will block until another greenlet
<a class="reference internal" href="#greenhouse.utils.Queue.get" title="greenhouse.utils.Queue.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>s an item out</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>item</strong> &#8211; the object to put into the queue, can be any type</li>
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether to block if the queue is already <a class="reference internal" href="#greenhouse.utils.Queue.full" title="greenhouse.utils.Queue.full"><tt class="xref py py-meth docutils literal"><span class="pre">full()</span></tt></a> (default
<tt class="xref docutils literal"><span class="pre">True</span></tt>)</li>
<li><strong>timeout</strong> (<em>int, float or None</em>) &#8211; the maximum time in seconds to block waiting. with the default of
<tt class="xref docutils literal"><span class="pre">None</span></tt>, it can wait indefinitely. this is unused if <cite>blocking</cite> is
<tt class="xref docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">Full</span></tt> if the queue is <a class="reference internal" href="#greenhouse.utils.Queue.full" title="greenhouse.utils.Queue.full"><tt class="xref py py-meth docutils literal"><span class="pre">full()</span></tt></a> and <cite>blocking</cite> is
<tt class="xref docutils literal"><span class="pre">False</span></tt>, or if <cite>timeout</cite> expires.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.put_nowait">
<tt class="descname">put_nowait</tt><big>(</big><em>item</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.put_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>put an item into the queue without any chance of blocking</p>
<p>this call is equivalent to <tt class="docutils literal"><span class="pre">put(blocking=False)</span></tt></p>
<p>;param item: the object to put into the queue, can be any type</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.qsize">
<tt class="descname">qsize</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.qsize" title="Permalink to this definition">¶</a></dt>
<dd><p>the number of queued pieces of data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Queue.task_done">
<tt class="descname">task_done</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Queue.task_done" title="Permalink to this definition">¶</a></dt>
<dd><p>mark that a &#8220;job&#8221; (corresponding to a <a class="reference internal" href="#greenhouse.utils.Queue.put" title="greenhouse.utils.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> or
<a class="reference internal" href="#greenhouse.utils.Queue.put_nowait" title="greenhouse.utils.Queue.put_nowait"><tt class="xref py py-meth docutils literal"><span class="pre">put_nowait()</span></tt></a> call) is finished</p>
<p>the <a class="reference internal" href="#greenhouse.utils.Queue.join" title="greenhouse.utils.Queue.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> method won&#8217;t complete until the number of
<a class="reference internal" href="#greenhouse.utils.Queue.task_done" title="greenhouse.utils.Queue.task_done"><tt class="xref py py-meth docutils literal"><span class="pre">task_done()</span></tt></a> calls equals the number of <a class="reference internal" href="#greenhouse.utils.Queue.put" title="greenhouse.utils.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> calls</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.LifoQueue">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">LifoQueue</tt><big>(</big><em>maxsize=0</em><big>)</big><a class="headerlink" href="#greenhouse.utils.LifoQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#greenhouse.utils.Queue" title="greenhouse.utils.Queue"><tt class="xref py py-class docutils literal"><span class="pre">greenhouse.utils.Queue</span></tt></a></p>
<p>a producer-consumer queue that produces items in LIFO order</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>maxsize</strong> (<em>int</em>) &#8211; optional limit to the amount of queued data, after which <tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt>
can block. the default of 0 turns off the limit, so <tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt> will
never block</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>mirrors the standard library <cite>Queue.LifoQueue</cite> API</p>
</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.PriorityQueue">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">PriorityQueue</tt><big>(</big><em>maxsize=0</em><big>)</big><a class="headerlink" href="#greenhouse.utils.PriorityQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#greenhouse.utils.Queue" title="greenhouse.utils.Queue"><tt class="xref py py-class docutils literal"><span class="pre">greenhouse.utils.Queue</span></tt></a></p>
<p>a producer-consumer queue that produces items in prioritized order</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>maxsize</strong> (<em>int</em>) &#8211; optional limit to the amount of queued data, after which <tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt>
can block. the default of 0 turns off the limit, so <tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt> will
never block</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>mirrors the standard library <cite>Queue.LifoQueue</cite> API</p>
</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Channel">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Channel</tt><a class="headerlink" href="#greenhouse.utils.Channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>a pipe for inter-coroutine messaging</p>
<p>mirrors Stackless Python&#8217;s <cite>stackless.channel</cite> API</p>
<dl class="attribute">
<dt id="greenhouse.utils.Channel.balance">
<tt class="descname">balance</tt><a class="headerlink" href="#greenhouse.utils.Channel.balance" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates the # of senders (positive) or waiters (negative) blocked</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Channel.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Channel.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel, ending new communications</p>
</dd></dl>

<dl class="attribute">
<dt id="greenhouse.utils.Channel.closed">
<tt class="descname">closed</tt><a class="headerlink" href="#greenhouse.utils.Channel.closed" title="Permalink to this definition">¶</a></dt>
<dd><p>the channel has been closed, and all data received (read-only)</p>
</dd></dl>

<dl class="attribute">
<dt id="greenhouse.utils.Channel.closing">
<tt class="descname">closing</tt><a class="headerlink" href="#greenhouse.utils.Channel.closing" title="Permalink to this definition">¶</a></dt>
<dd><p>the channel has been closed (read-only)</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Channel.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Channel.next" title="Permalink to this definition">¶</a></dt>
<dd><p>receive data on the channel.</p>
<p>if there is a waiting sender, then re-schedule it and return its sent
item now, otherwise block until another coroutine sends something.</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Channel.open">
<tt class="descname">open</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Channel.open" title="Permalink to this definition">¶</a></dt>
<dd><p>allow communications again on a previously closed channel</p>
</dd></dl>

<dl class="attribute">
<dt id="greenhouse.utils.Channel.preference">
<tt class="descname">preference</tt><a class="headerlink" href="#greenhouse.utils.Channel.preference" title="Permalink to this definition">¶</a></dt>
<dd><p>prefer senders (positive) or receivers (negative, default)</p>
<p>if receivers are preferred, then on a channel with blocked receivers,
a send() call will jump straight to the awoken receiver bypassing the
scheduler entirely.</p>
<p>similarly if senders are preferred, then with blocked senders receive()
calls bypass the scheduler and jump straight to the awoken sender.</p>
<p>a 0 preference always re-schedules awoken coroutines on both sides.</p>
</dd></dl>

<dl class="attribute">
<dt id="greenhouse.utils.Channel.queue">
<tt class="descname">queue</tt><a class="headerlink" href="#greenhouse.utils.Channel.queue" title="Permalink to this definition">¶</a></dt>
<dd><p>the first coroutine waiting on the channel, or None</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Channel.receive">
<tt class="descname">receive</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Channel.receive" title="Permalink to this definition">¶</a></dt>
<dd><p>receive data on the channel.</p>
<p>if there is a waiting sender, then re-schedule it and return its sent
item now, otherwise block until another coroutine sends something.</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Channel.send">
<tt class="descname">send</tt><big>(</big><em>item</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Channel.send" title="Permalink to this definition">¶</a></dt>
<dd><p>send data over the channel.</p>
<p>if there is a waiting receiver, re-schedule it and return immediately,
otherwise block until there is a receiver to accept the item.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="greenhouse.utils.Counter">
<em class="property">class </em><tt class="descclassname">greenhouse.utils.</tt><tt class="descname">Counter</tt><a class="headerlink" href="#greenhouse.utils.Counter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>a counter object that can block</p>
<dl class="method">
<dt id="greenhouse.utils.Counter.acquire">
<tt class="descname">acquire</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Counter.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>increment the counter</p>
</dd></dl>

<dl class="attribute">
<dt id="greenhouse.utils.Counter.count">
<tt class="descname">count</tt><a class="headerlink" href="#greenhouse.utils.Counter.count" title="Permalink to this definition">¶</a></dt>
<dd><p>the current integer value of the counter</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Counter.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Counter.release" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement the counter, potentially waking blocked waiters</p>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Counter.wait">
<tt class="descname">wait</tt><big>(</big><big>)</big><a class="headerlink" href="#greenhouse.utils.Counter.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until the count has reached 0</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this method can block the current greenlet</p>
</div>
</dd></dl>

<dl class="method">
<dt id="greenhouse.utils.Counter.wait_for">
<tt class="descname">wait_for</tt><big>(</big><em>num</em><big>)</big><a class="headerlink" href="#greenhouse.utils.Counter.wait_for" title="Permalink to this definition">¶</a></dt>
<dd><p>block until the count is &lt;= a particular number</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this method can block the current greenlet</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num</strong> (<em>int</em>) &#8211; the number to wait for the count to get down to</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="io.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">greenhouse.io</span></tt> &#8211; Cooperative I/O Drop-Ins</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pool.html"
                        title="next chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">greenhouse.pool</span></tt> &#8211; Managed Greenlet Pools</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/greenhouse/utils.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pool.html" title="greenhouse.pool – Managed Greenlet Pools"
             >next</a> |</li>
        <li class="right" >
          <a href="io.html" title="greenhouse.io – Cooperative I/O Drop-Ins"
             >previous</a> |</li>
        <li><a href="../index.html">greenhouse v0.6.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Travis J Parker.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>